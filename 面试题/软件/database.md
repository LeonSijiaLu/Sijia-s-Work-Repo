# MySQL 

1. BinLog 格式
    a. Statement 记录每一条修改数据的 SQL 语句
    b. Row 记录每一个被修改的内容。不会单独记录 function, trigger. 只会记录改变的内容

2. 主从复制
    a. Master 把数据放入 binlog
    b. Slave 从 Master 的 binlog 拉取数据放入自己的 relay logs
    c. Slave 执行 relay logs 内容

3. InnoDB vs MyISAM
    a. InnoDB 支持事务
    b. InnoDB 支持外键

4. 多少种日志
    a. 错误日志：记录出错内容和警告等
    b. 查询日志：记录所有对数据库的请求
    c. 慢查询日志：记录运行时间超过阈值的内容
    d. 二进制日志：记录对数据库执行更改的操作
    e. 中继日志：用来帮助 slave 同步
    f. 事务日志：redo log, undo log
        undo 日志用来存放修改前的值。
        redo 日志用来记录修改之后的数值。主要会为了防止 DB Crash 的时候有数据在内存没有读出来
        先记录 undo, 之后修改数值，然后记录 redo 

5. 事务隔离等级
    a. 可读未提交
    b. 可读已提交
    c. 可重复读
    d. 串行

6. 范式
    a. 第一范式：每一列都是最简数据
    b. 第二范式：必须有主键，并且非主键列完全依赖主键
    c. 第三范式：非主键不互相依赖
    d. BCNF：主键不互相依赖

7. 分库分表
    a. 为什么要分库分表？
        1) 首先分表是因为单表数据量太大，极大地影响了SQL执行效率。分表就是把一张表拆分成几张表
        2) 分库是因为并发量太大，IO限制

    b. 水平拆分
        1) 把一张表的内容放到多个表，多个库内。这样可以对抗高并发

    c. 垂直拆分
        1) 把一张表竖着拆分成结构不同的小表。这一把访问频率低的列放到性能差一些的机器

    d. 直接拆分
        1) 单机上把一个表分成多个表

8. 怎么解决 ID 主键自增问题
    a. UUID。随机生成，但是不是自增，作为主键性能不好。而且太长
    b. 获取当前时间，并发太高的时候实现肯定报错
    c. snowflake算法。可以实现自增的唯一ID。一共64bit，其中一部分时间戳，一部分机器id, 一部分自增ID

9. 动态扩容、缩容，分库分表怎么做
    a. 按照 ID range 进行拆分。但是分布式环境下不适合迁移
    b. 进行数据库扩容，增加数据库数量
        1) 使用 mod 进行路由，把数据库加入
    c. 成倍的增加表的数量
        1) 通过 mod 把数据放入不同的表
    d. 一致性 HASH
        1) 使用环形 hash. hash 环上有最大值和最小值，头尾相连。
        2) 使用 key mod 64 这样类似的 hash 公式，只要这个 hash 公式有最大值或者最小值就行。
        3) 对 IP 进行 hash, 根据数据库的位置，放入数据库

10. 分布式事务
    a. 使用后端程序和事务配合
    b. 把一个大事务分成多个可以在单node上执行的小事务。如果任何事务错误，回滚
    c. 使用二阶段提交
        * 把一个事务处理过程拆分成投票和事务提交。整个过程包括一个协调者，多个参与者
        * 第一阶段投票：
            1) 协调者向所有参与者发送事务执行请求，等待回复
            2) 每个参与者执行事务但并不提交
            3) 参与者把执行情况返回给协调者
        * 第二阶段事务提交：
            1) 如果全部成功，协调者发送 commit 请求
            2) 只要有任何失败，全部回滚
        * 但不好，只要有任何一个数据库出现问题，整个分布式出现问题或者阻塞
    d. 使用三阶段提交
        * can_commit, pre_commit, do_commit
        * Pre_Commit
            1) 协调者向所有参与者发送commit预测请求，预测能否成功执行事务，并返回
            2) 如果协调者等待超时，发送 abort
        * Can_Commit
            3) 如果全部ok, 发送 can_commit， 执行事务但是不提交
        * Do_Commit
            4) 执行 commit, 如果报错，全部回滚

11. 限流
    a. 令牌桶算法